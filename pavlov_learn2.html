<!DOCTYPE html>
<head>
  <title>minimal demo</title>

  <!-- CSS goes here -->
  <style>
    body {
      background-color: #FFF; /* example... */
    }
  </style>

  <!-- import convnetjs library -->
  <script src="pavlov_learn.js"></script>

  <!-- javascript goes here -->
  <script type="text/javascript">

    var float_rand = function (a, b) {
      return Math.random() * (b - a) + a;
    };

    var float_equal = function (a, b) {
      return Math.abs(a - b) < 0.0000001;
    };

    var world = function () {
      this.clock = 0;
      this.state_all = ["A", "B"];
      this.agent_action_all = ["0", "1", "2"];
      this.agent_action = this.agent_action_all[0];
      this.agent = new agent(this.state_all, this.agent_action_all);
      this.reward = 0;
      this.state = this.state_all[0];
    };
    world.prototype = {
      reward_to_agent: function () {
        this.reward = 0;

        if (this.clock % 100 <= 50) {
          this.state = this.state_all[0];
          if (this.agent_action === this.agent_action_all[1]) {
            this.reward = 1;
          }
        } else {
          this.state = this.state_all[1];
          if (this.agent_action === this.agent_action_all[2]) {
            this.reward = 1;
          }
        }
      },

      action_to_state: function (agent_action) {
        this.agent_action = agent_action;
      },


      rule: function () {
        if (this.clock % 20 == 0) {
          console.log("world and agent action:", this.reward, this.state, this.agent_action);
          console.log("neuron_all", this.agent.brain.neuron_all);
        }
        var agent_action = this.agent.tick(this.reward, this.state);
        this.action_to_state(agent_action);
        this.reward_to_agent();
      },

      tick: function () {
        this.clock++;
//        console.log("clock = ", this.clock);
//        if(this.clock < 100)
        this.rule();
      }
    };

    var agent = function (state_all, agent_action_all) {
      this.state_all = state_all;
      this.agent_action_all = agent_action_all;
      this.control_finger_value = float_rand(0, 1);
      var input_neuron_num = 1;
      var output_neuron_num = 1;
      this.brain = new brain(10, input_neuron_num, output_neuron_num);
    };
    agent.prototype = {
      tick: function (reward, state) {
        this.assign_reward(reward);
        this.eye_to_brain(state);
        this.control_finger_value = this.brain.tick();
        return this.finger_to_world(this.control_finger_value);
      },

      state_to_input_neuron_value: function (state) {
        var total = this.state_all.length;
        var error = true;
        var i;
        for (i = 0; i < total; i++) {
          if (state === this.state_all[i]) {
            error = false;
            break;
          }
        }
        if (error) {
          console.log("error");
        }
        return 1 / total * (i + 0.5);
      },

      eye_to_brain: function (state) {
        var value = this.state_to_input_neuron_value(state);
        this.brain.activate_neuron(1, value);
      },

      finger_to_world: function (control_finger_value) {
        return this.agent_action_all[Math.floor(control_finger_value * this.agent_action_all.length)];
      },

      assign_reward: function (reward) {
//        this.brain.activate_neuron(2, this.control_finger_value);
//        console.log("this.output_neuron_action_index:", this.brain.output_neuron_action_index);
        this.brain.neuron_all[this.brain.output_neuron_action_index].world_backward(reward);
      }
    };


    function tick() {
      w.tick();
    }


    var w;
    function start() {
      w = new world();
      setInterval(tick, 1000);
    }

    var brain = function (neuron_num_total, input_total, output_total) {
      this.neuron_num_total = neuron_num_total;
      this.input_total = input_total;
      this.output_total = output_total;
      var index = 0;
      this.neuron_all = [];

      this.input_neuron_index = index;
      var input_neuron = new neuron(1, index++, this.total);
      this.neuron_all.push(input_neuron);

//      this.input_enable_neuron_index = index;
//      var input_enable_neuron = new neuron(4, index++, this.total);
//      this.neuron_all.push(input_enable_neuron);

      this.output_neuron_index = index;
      this.output_neuron_action_index = index;
      var output_neuron = new neuron(2, index++, this.total);
      this.neuron_all.push(output_neuron);

//      this.output_enable_neuron_index = index;
//      var output_enable_neuron = new neuron(5, index++, this.total);
//      this.neuron_all.push(output_enable_neuron);

//      var alive_neuron = new neuron(3, index++, this.total);
//      this.neuron_all.push(alive_neuron);

      for (; index < this.neuron_num_total; index++) {
        this.neuron_all.push(new neuron(0, index, this.neuron_num_total))
      }
    };
    brain.prototype = {
      tick: function () {
        var neuron_output_value = float_rand(0, 1);
        var i;

        var neuron_select_value = [];
        var output_neuron_enable = false;
        var output_neuron_idx;
        var output_neuron_select_reward_cnt = 0;
        for (i = 0; i < this.neuron_all.length; i++) {
          this.neuron_all[i].forward();
          if (this.neuron_all[i].reward_cnt > reward_cnt_enable_select){
            neuron_select_value.push(this.neuron_all[i].select_value);
          }
          if(this.neuron_all[i].type === 2){
            if (this.neuron_all[i].reward_cnt > output_neuron_select_reward_cnt){
              output_neuron_select_reward_cnt = this.neuron_all[i].reward_cnt;
              output_neuron_idx = i;
              this.output_neuron_action_index = i;
              output_neuron_enable = true;
            }
          }
        }

        for (i=0;i<neuron_select_value.length;i++){
          this.select_value_to_policy(neuron_select_value[i]);
        }

        if(output_neuron_enable){
          neuron_output_value = this.select_value_to_policy(this.neuron_all[this.output_neuron_action_index].select_value);
        }else{
          console.log("error ! output_neuron_enable");
        }

        return neuron_output_value;
      },

      activate_neuron:function(type, value){
//        var index = 0;
//        if (type === 1){
//          index = this.input_enable_neuron_index;
//        } else if (type === 2){
//          index = this.input_enable_neuron_index;
//        } else {
//          console.log("error");
//        }
//        var select_policy_value = this.select_value_to_policy(this.neuron_all[index].select_value);
//        console.log("select_policy_value", select_policy_value);
//        if (select_policy_value > threshold) {
          console.log("activate_neuron");
          var has_value = false;
          var has_idx = 0;
          var reward_cnt_least_idx = 0;
//          var max_select_value_idx = 0;
          for (var i=0;i<this.neuron_all.length;i++){
            if(this.neuron_all[i].type === type){
              if(float_equal(this.neuron_all[has_idx].weight_value, value)){
                has_value = true;
                has_idx =i;
              }
//              if (this.neuron_all[max_select_value_idx].reward_cnt < this.neuron_all[i].reward_cnt){
//                max_select_value_idx = i;
//              }
            }
            if (this.neuron_all[reward_cnt_least_idx].reward_cnt > this.neuron_all[i].reward_cnt){
              reward_cnt_least_idx = i;
            }
          }
//        }

        console.log("has_value:", has_value, "has_idx:", has_idx);
        console.log("reward_cnt_least_idx", reward_cnt_least_idx);
        if (has_value){
          this.neuron_all[has_idx].world_backward(1);
        } else {
          if (this.neuron_all[reward_cnt_least_idx].reward_cnt < reward_cnt_input) {
            this.neuron_all[reward_cnt_least_idx].replace(type, value, this.neuron_all[reward_cnt_least_idx].select_value);
          }
        }
      },

      select_value_to_policy: function (select_value) {
        if (select_value >= 1) {
          console.log("error weight_value=", select_value);
        }
//        console.log("neuron_num_total", this.brain.neuron_num_total, Math.pow(2, this.brain.neuron_num_total));
        var select_index = Math.floor(select_value * Math.pow(2, this.neuron_num_total));
        var sum = 0;
        var cnt = 0;
        for (var i = 0; i < 1000; i++) {
          if ((select_index & 1) === 1) {
            cnt++;
            sum += this.neuron_all[i].weight_value;
            this.neuron_all[i].other_neuron_backward(false);
//            console.log("1", i)
          } else {
//            console.log("0", i, select_index)
          }
          select_index /= 2;
          if (select_index < 1) {
            break;
          }
        }
        var avg = sum / cnt;
//        console.log("avg=", sum/cnt);
//        console.log("select_index:",select_index);

        return avg;
      },
    };

    var reward_cnt_total = 1000;
    var reward_cnt_input = 300;
    var reward_cnt_enable_select = 500;
    var epsilon_min = 0.05;
    var neuron = function (type, index, total) {
      this.type = type;//0-normal neuron, 1-input neuron, 2-output neuron, 3-alive neuron, 4-input enable neuron, 5-output enable neuron
      this.total = total;
      this.index = index;
      if (this.type === 3) {
        this.reward_cnt = reward_cnt_total;
      } else {
        this.reward_cnt = Math.floor(float_rand(0, 1) * reward_cnt_total);
      }
      this.weight_value = float_rand(0, 1);
      this.select_value = float_rand(0, 1);
    };
    neuron.prototype = {
      get_name: function () {
        var name_str = ["normal", "input", "output", "alive", "input enable", "output enable"];
        if (this.type < 6) {
          return name_str[this.type];
        } else {
          console.log("error");
          return "error";
        }
      },
      forward: function () {
        if (this.reward_cnt == 0 && this.type === 3) {
          return -1;
        } else if (this.reward_cnt > 0) {
          this.reward_cnt--;
        }
//        var epsilon = Math.min(1.0, Math.max(epsilon_min, 1.0 - (reward_cnt_total - this.reward_cnt) / reward_cnt_total));
//        if (float_rand(0, 1) > epsilon) {
//          this.select_value = float_rand(0, 1);
//        }
//        return this.select_value * this.total;
      },

      replace:function(type, weight_value, select_value){
        this.type = type;
        this.reward_cnt = reward_cnt_input;
        this.weight_value = weight_value;
        this.select_value = select_value;
      },

      other_neuron_backward: function (from_alive_neuron) {
        if ((from_alive_neuron && this.reward_cnt == 0 && this.type === 1 || this.type === 2)
          || !from_alive_neuron) {
          this.reward_cnt += 1;
          if (this.reward_cnt > reward_cnt_total) this.reward_cnt = reward_cnt_total;
        }
      },

//      get_weight_value: function (reward) {
//        if (this.type === 3) {
//          return float_rand(0, 1);
//        } else {
//          return this.weight_value;
//        }
//      },

      world_backward: function (reward) {
        if (this.type === 2 || this.type === 1) {
          this.reward_cnt += Math.floor(reward * 100);
        } else {
//          console.log("error");
        }

        if (this.reward_cnt > reward_cnt_total) {
          this.reward_cnt = reward_cnt_total;
        } else if (this.reward_cnt < 0) {
          this.reward_cnt = 0;
        }
      }
    }

  </script>
</head>

<body onload="start()">
<div id="egdiv"></div>
</body>
</html>